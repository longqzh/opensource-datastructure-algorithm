10 100
35 6 6
100 one number 1 1 0 1 1 1
100 two number 1 1 0 1 6 1
100 three number 1 1 0 6 1 1
100 four number 1 1 0 6 6 1
400 1 1 1 one number
400 1 2 0
500 number 4
500 fruit 0
200 apple 0
300 fruit 0
100 apple fruit 3 3 1 5 6 1
100 kiwi fruit 2 3 1 1 1 1
100 banana fruit 5 5 1 1 1 0
500 fruit 15
400 3 3 1 apple fruit
200 one 1
200 five 0
500 number 3
400 1 1 0
300 number 3
500 number 0
400 6 1 0
300 number 0
300 fruit 2
300 fruit 0
500 number 0
500 fruit 0
500 snack 0
100 test test 3 4 0 2 3 1
100 tast test 1 1 0 3 4 0
100 tvst test 6 2 0 1 2 0
100 taest test 2 2 0 6 6 0
500 test 12
200 test 1
500 test 0
100 10 10
100 bgifkqxdv jbesogl 2 2 0 4 2 1
100 gkyriroyai lbm 2 2 0 5 4 1
100 grc lcpfj 2 2 0 5 8 1
100 iegmdx lm 2 2 0 2 7 1
100 imvqmujfz mfpsbgeku 2 2 0 2 3 1
100 jbesogl nxshmnuf 2 2 0 4 6 1
100 lbm omxjxihk 2 2 0 7 8 1
100 lcpfj ppist 2 2 0 7 2 1
100 lm sighhj 2 2 0 7 5 1
100 mfpsbgeku szev 2 2 0 2 5 1
200 lcpfj 1
300 lm 1
400 5 8 1 grc lcpfj
400 2 7 0
400 7 2 0
400 7 5 1 lm sighhj
100 likcwgmmu gkyriroyai 3 4 1 8 9 1
400 7 1 1 likcwgmmu gkyriroyai
400 9 4 1 likcwgmmu gkyriroyai
100 frugyo wnuy 10 1 1 4 8 1
400 1 10 1 frugyo wnuy
400 10 10 1 frugyo wnuy
100 aacye ppist 2 3 1 7 9 1
400 9 5 1 aacye ppist
400 10 7 1 aacye ppist
100 dq bgifkqxdv 1 4 1 3 10 1
400 1 1 1 dq bgifkqxdv
400 1 4 1 dq bgifkqxdv
100 zukg nxshmnuf 1 4 1 4 10 1
400 10 1 1 zukg nxshmnuf
400 10 4 1 zukg nxshmnuf
100 uwqsyu omxjxihk 3 1 1 2 6 1
400 2 1 1 uwqsyu omxjxihk
400 4 1 1 uwqsyu omxjxihk
100 nzwr ppist 2 2 1 3 2 1
400 1 7 1 nzwr ppist
400 2 8 1 nzwr ppist
100 pb bgifkqxdv 4 1 1 6 6 1
400 1 9 1 pb bgifkqxdv
400 4 9 1 pb bgifkqxdv
100 bxvhaunu lbm 1 1 1 2 1 1
400 5 1 1 bxvhaunu lbm
400 5 1 1 bxvhaunu lbm
100 vce lm 1 2 1 7 1 1
400 6 1 1 vce lm
400 6 2 1 vce lm
100 hsaeyewijv imvqmujfz 2 1 1 3 10 1
400 2 2 1 hsaeyewijv imvqmujfz
400 3 2 1 hsaeyewijv imvqmujfz
100 sqgqjddzj sighhj 1 2 1 4 10 1
400 4 4 1 sqgqjddzj sighhj
400 4 5 1 sqgqjddzj sighhj
100 ninotpupyl szev 3 1 1 5 7 1
400 6 7 1 ninotpupyl szev
400 8 7 1 ninotpupyl szev
100 mcwxzra gkyriroyai 2 2 1 1 8 1
400 9 8 1 mcwxzra gkyriroyai
400 10 9 1 mcwxzra gkyriroyai
100 hvrbjkc nxshmnuf 1 2 1 5 7 1
400 1 5 1 hvrbjkc nxshmnuf
400 1 6 1 hvrbjkc nxshmnuf
100 exmowicauu lm 2 1 1 7 5 1
400 3 8 1 exmowicauu lm
400 4 8 1 exmowicauu lm
100 duipsi vi 1 1 1 3 5 1
400 6 3 1 duipsi vi
400 6 3 1 duipsi vi
100 oa vpbpvskfz 5 9 1 2 2 0
300 omxjxihk 2
300 gkyriroyai 2
300 wnuy 1
100 dvnu gkyriroyai 7 1 1 7 3 1
400 1 10 1 dvnu gkyriroyai
400 7 10 1 dvnu gkyriroyai
100 wwdfytreou szev 3 4 1 2 5 1
400 7 1 1 wwdfytreou szev
400 9 4 1 wwdfytreou szev
100 ixjdcjfn mfpsbgeku 3 2 1 7 2 1
400 7 8 1 ixjdcjfn mfpsbgeku
400 9 9 1 ixjdcjfn mfpsbgeku
100 kn iegmdx 1 2 1 2 8 1
400 10 8 1 kn iegmdx
400 10 9 1 kn iegmdx
100 ngmwfpujw imvqmujfz 1 1 1 7 2 1
400 2 1 1 ngmwfpujw imvqmujfz
400 2 1 1 ngmwfpujw imvqmujfz
100 qhgflc imvqmujfz 2 1 1 3 10 1
400 3 1 1 qhgflc imvqmujfz
400 4 1 1 qhgflc imvqmujfz
100 gnlbvcxqxh gkyriroyai 3 1 1 7 2 1
400 8 10 1 gnlbvcxqxh gkyriroyai
400 10 10 1 gnlbvcxqxh gkyriroyai
100 wrxouk sighhj 3 1 1 9 2 0
300 sighhj 2
300 nxshmnuf 3
300 iegmdx 1
100 ez ppist 2 2 1 5 4 1
400 7 5 1 ez ppist
400 8 6 1 ez ppist
100 oslkos vpbpvskfz 2 2 1 1 1 1
50 25 37
100 bucqgnic oelvks 23 4 0 11 18 0
100 twb oelvks 4 12 0 9 10 1
100 zurk lipylbk 6 22 0 6 9 0
100 eiqv lipylbk 4 35 0 10 7 0
100 autqiaodpi qdpknzaesw 12 21 0 6 13 0
100 urdub qdpknzaesw 23 12 1 17 3 1
100 voi qdpknzaesw 5 28 0 15 5 0
100 xfntkgy lipylbk 22 16 0 2 1 0
100 gnkdloty oelvks 19 24 0 7 28 0
100 zzdmvvkek lipylbk 25 16 0 8 11 0
500 qdpknzaesw 276
500 qdpknzaesw 276
300 lipylbk 0
500 lipylbk 0
400 19 16 0
100 jbtjsgr qdpknzaesw 13 9 1 15 29 1
400 17 23 1 urdub qdpknzaesw
200 cm 0
500 qdpknzaesw 393
100 iilcwgpx lipylbk 11 8 0 1 15 0
500 oelvks 48
400 16 5 0
300 oelvks 1
100 icjev qdpknzaesw 21 9 0 25 2 0
200 iilcwgpx 0
400 11 15 0
500 lipylbk 0
500 qdpknzaesw 393
200 um 0
500 oelvks 0
300 lipylbk 0
100 ddpobizmx qdpknzaesw 18 19 0 23 7 0
500 oelvks 0
300 oelvks 0
200 pqzwinmfkx 0
500 qdpknzaesw 393
100 lfq lipylbk 10 12 0 22 21 0
100 io oelvks 22 11 0 23 15 0
100 hjx lipylbk 24 6 0 11 37 0
100 coojgxvjpn oelvks 12 9 0 18 16 0
500 oelvks 0
400 1 10 0
200 rag 0
300 lipylbk 0
400 7 6 1 jbtjsgr qdpknzaesw
500 lipylbk 0
200 vjwoqs 0
400 21 11 0
300 oelvks 0
200 xiqti 0


#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <string.h>

#define ADD_ITEM                100
#define REMOVE_ITEM_BY_NAME     200
#define REMOVE_ITEM_BY_TAG      300
#define GET_ITEM                400
#define GET_AREA                500

extern void init(int R, int C);
extern int addItem(char name[], char tag[], int height, int width,
                   int mode, int r, int c);
extern int removeItemByName(char name[]);
extern int removeItemByTag(char tag[]);
extern int getItem(int r, int c, char name[], char tag[]);
extern int getArea(char tag[]);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

static int run(int Result) {
    int N, R, C;

    scanf("%d %d %d", &N, &R, &C);

    init(R, C);

    for (int i = 0; i < N; ++i) {
        int cmd = 0;
        char name[11];
        char tag[11];
        char userName[11];
        char userTag[11];
        int height, width, mode, r, c;
        int ans, res;

        scanf("%d", &cmd);

        switch (cmd) {
        case ADD_ITEM:
            scanf("%s %s", name, tag);
            scanf("%d %d %d %d %d", &height, &width, &mode, &r, &c);

            res = addItem(name, tag, height, width, mode, r, c);

            scanf("%d", &ans);
            if (res != ans) Result = 0;
            break;

        case REMOVE_ITEM_BY_NAME:
            scanf("%s", name);

            res = removeItemByName(name);

            scanf("%d", &ans);
            if (res != ans) Result = 0;
            break;

        case REMOVE_ITEM_BY_TAG:
            scanf("%s", tag);

            res = removeItemByTag(tag);

            scanf("%d", &ans);
            if (res != ans) Result = 0;
            break;

        case GET_ITEM:
            scanf("%d %d", &r, &c);

            res = getItem(r, c, userName, userTag);

            scanf("%d", &ans);
            if (res != ans) Result = 0;
            if (ans == 1) {
                scanf("%s %s", name, tag);
                if (strcmp(name, userName) != 0) Result = 0;
                if (strcmp(tag, userTag) != 0) Result = 0;
            }
            break;

        case GET_AREA:
            scanf("%s", tag);

            res = getArea(tag);

            scanf("%d", &ans);
            if (res != ans) Result = 0;
            break;

        default:
            Result = 0;
            break;
        }
    }

    return Result;
}


int main() {
    setbuf(stdout, NULL);

	//freopen("sample_input.txt", "r", stdin);
	
    int T, Result;
    scanf("%d %d", &T, &Result);

    for (int tc = 1; tc <= T; tc++) {
        printf("#%d %d\n", tc, run(Result));
    }

    return 0;
}



#define MAX_SIZE    301
#define MAX_ITEM    301
 
#define MAX_TABLE   607
#define NULL        0
 
void mstrcpy(char *dest, const char *src)
{
    int i = 0;
    while (src[i] != '\0')
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = src[i];
}
 
 
unsigned long long strToNum(const char* str) {
    unsigned long long res = 0LL;
 
    while (*str) {
        res = (res << 5) + (*str - 'a' + 1);
        str++;
    }
 
    return res;
}
 
struct Point {
    int r;
    int c;
};
 
struct Item {
    unsigned long long name;
    unsigned long long tag;
 
    char strName[11];
    char strTag[11];
 
    int sr, sc;
    int er, ec;
 
    int size;
    int height;
    int width;
 
    bool del;
 
    Item* tagNext;
    Item* nameNext;
};
Item itemPool[MAX_ITEM];
int itemCnt;
 
Item* nameTable[MAX_TABLE];
Item* tagTable[MAX_TABLE];
 
Item* map[MAX_SIZE][MAX_SIZE];
int R, C;
 
void init(int R, int C) {
    ::R = R;
    ::C = C;
 
    itemCnt = 0;
 
    for (register int i = 0; i < MAX_TABLE; i++) {
        nameTable[i] = NULL;
        tagTable[i] = NULL;
    }
 
    for (register int i = 0; i <= R; i++) {
        for (int j = 0; j <= C; j++) {
            map[i][j] = NULL;
        }
    }
}
 
void setMap(Item* item, int sr, int sc, int height, int width) {
    for (register int i = 0; i < height; i++) {
        for (register int j = 0; j < width; j++) {
            map[sr + i][sc + j] = item;
        }
    }
}
 
Item* setItem(int sr, int sc, int height, int width, char strName[11], char strTag[11]) {
    Item* item = &itemPool[itemCnt++];
    item->sr = sr;
    item->sc = sc;
    item->er = sr + height - 1;
    item->ec = sc + width - 1;
 
    item->size = height * width;
    item->height = height;
    item->width = width;
 
    item->name = strToNum(strName);
    item->tag = strToNum(strTag);
 
    mstrcpy(item->strName, strName);
    mstrcpy(item->strTag, strTag);
 
    item->del = false;
     
    item->nameNext = nameTable[item->name % MAX_TABLE];
    nameTable[item->name % MAX_TABLE] = item;
 
    item->tagNext = tagTable[item->tag % MAX_TABLE];
    tagTable[item->tag % MAX_TABLE] = item;
 
    return item;
}
 
Item* check(int sr, int sc, int height, int width) {
    int er = sr + height - 1;
    int ec = sc + width - 1;
 
    if (map[sr][sc] != NULL)
        return map[sr][sc];
    if (map[sr][ec] != NULL)
        return map[sr][ec];
    if (map[er][sc] != NULL)
        return map[er][sc];
    if (map[er][ec] != NULL)
        return map[er][ec];
 
    register Item* item;
    for (register int i = 0; i < itemCnt; i++) {
        item = &itemPool[i];
        if (item->del == false && !(sc > item->ec || sr > item->er || ec < item->sc || er < item->sr))
            return item;
    }
 
    return NULL;
}
 
Point getPoint(int height, int width) {
    register int sr = 1;
    register int sc = 1;
    register int nextC = C + 1;
 
    register int er, ec;
    while (true) {
        er = sr + height - 1;
        ec = sc + width - 1;
 
        if (ec > C) {
            return { -1, -1 };
        }
 
        if (er > R) {
            sr = 1;
            sc = nextC;
            nextC = C + 1;
            continue;
        }
 
        Item* item = check(sr, sc, height, width);
        if (item == NULL)
            return { sr, sc };
 
        sr = item->er + 1;
        if (item->ec + 1 < nextC) {
            nextC = item->ec + 1;
        }
    }
}
 
int addItem(char name[], char tag[], int height, int width,
    int mode, int r, int c) {
     
    if (mode == 0) {
        if (r + height - 1 > R || c + width - 1 > C)
            return 0;
 
        if (check(r, c, height, width) != NULL)
            return 0;
    }
    else { //mode == 1, 자동배치
        Point point = getPoint(height, width);
        if (point.r == -1)
            return 0;
 
        r = point.r;
        c = point.c;
    }
 
    Item* item = setItem(r, c, height, width, name, tag);
    setMap(item, r, c, height, width);
     
    return 1;
}
 
int removeItemByName(char strName[]) {
    unsigned long long name = strToNum(strName);
 
    Item* cur = nameTable[name % MAX_TABLE];
    while (cur != NULL) {
        if (cur->del == false && cur->name == name) {
            cur->del = true;
            setMap(NULL, cur->sr, cur->sc, cur->height, cur->width);
 
            return 1;
        }
 
        cur = cur->nameNext;
    }
 
    return 0;
}
 
int removeItemByTag(char strTag[]) {
    int res = 0;
    unsigned long long tag = strToNum(strTag);
 
    Item* cur = tagTable[tag % MAX_TABLE];
    while (cur != NULL) {
        if (cur->del == false && cur->tag == tag) {
            res++;
 
            cur->del = true;
            setMap(NULL, cur->sr, cur->sc, cur->height, cur->width);
        }
 
        cur = cur->tagNext;
    }
 
    return res;
}
 
int getItem(int r, int c, char name[], char tag[]) {
    if (map[r][c] == NULL)
        return 0;
 
    mstrcpy(name, map[r][c]->strName);
    mstrcpy(tag, map[r][c]->strTag);
 
    return 1;
}
 
int getArea(char strTag[]) {
    int res = 0;
    unsigned long long tag = strToNum(strTag);
 
    Item* cur = tagTable[tag % MAX_TABLE];
    while (cur != NULL) {
        if (cur->del == false && cur->tag == tag) {
            res += cur->size;
        }
         
        cur = cur->tagNext;
    }
     
    return res;
}
